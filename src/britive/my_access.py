from . import exceptions


class MyAccess:
    """
    This class is meant to be called by end users (as part of custom API integration work or the yet to be built
    Python based Britive CLI tooling). It is an API layer on top of the actions that can be performed on the
    "My Access" page of the Britive UI.
    
    No "administrative" access is required by the methods in this class. Each method will only return resources/allow
    actions which are permitted to be performed by the user/service identity, as identified by an API token or
    interactive login bearer token.

    It is entirely possible that an administrator who makes these API calls could get nothing returned, as that
    administrator may not have access to any profiles.
    """

    def __init__(self, britive):
        self.britive = britive
        self.base_url = f'{self.britive.base_url}/access'

    def list_profiles(self):
        """
        List the profiles for which the user has access.

        :return: List of profiles.
        """

        return self.britive.get(self.base_url)

    def list_checked_out_profiles(self) -> list:
        """
        Return list of details on currently checked out profiles for the user.

        :return: List of checked out profiles.
        """

        return self.britive.get(f'{self.base_url}/app-access-status')

    def checkout(self, profile_id: str, environment_id: str, programmatic: bool = True,
                 include_credentials: bool = False) -> dict:
        """
        Checkout a profile.

        Programmatic access is only available for the following cloud providers.

        - AWS
        - Azure
        - GCP

        :param profile_id: The ID of the profile. Use `list_profiles()` to obtain the eligible profiles.
        :param environment_id: The ID of the environment. Use `list_profiles()` to obtain the eligible environments.
        :param programmatic: True for programmatic credential checkout. False for console checkout.
        :param include_credentials: True if tokens should be included in the response. False if the caller wishes to
            call `credentials()` at a later time. If True, the `credentials` key will be included in the response which
            contains the response from `credentials()`.
        :return: Details about the checked out profile, and optionally the credentials generated by the checkout.
        """

        params = {
            'accessType': 'PROGRAMMATIC' if programmatic else 'CONSOLE'
        }

        transaction = self.britive.post(f'{self.base_url}/{profile_id}/environments/{environment_id}', params=params)

        if include_credentials:
            transaction['credentials'] = self.credentials(transaction['transactionId'])
        return transaction

    def checkout_by_name(self, profile_name: str, environment_name: str, programmatic: bool = True,
                         include_credentials: bool = False) -> dict:
        """
        Checkout a profile by supplying the names of entities vs. the IDs of those entities.

        Programmatic access is only available for the following cloud providers.

        - AWS
        - Azure
        - GCP

        :param profile_name: The name of the profile. Use `list_profiles()` to obtain the eligible profiles.
        :param environment_name: The name of the environment. Use `list_profiles()` to obtain the eligible environments.
        :param programmatic: True for programmatic credential checkout. False for console checkout.
        :param include_credentials: True if tokens should be included in the response. False if the caller wishes to
            call `credentials()` at a later time. If True, the `credentials` key will be included in the response which
            contains the response from `credentials()`.
        :return: Details about the checked out profile, and optionally the credentials generated by the checkout.
        """

        ids = self._get_profile_and_environment_ids_given_names(profile_name, environment_name)

        return self.checkout(
            profile_id=ids['profile_id'],
            environment_id=ids['environment_id'],
            programmatic=programmatic,
            include_credentials=include_credentials
        )

    def credentials(self, transaction_id: str) -> dict:
        """
        Return credentials of a checked out profile given the transaction ID.

        Will automatically determine the type of checkout (programmatic or console) and return the appropriate
        details.

        :param transaction_id: The ID of the transaction.
        :return: Credentials associated with the checked out profile represented by the specified transaction.
        """

        # step 1: get the details of the transaction so we can make the appropriate API call
        transaction = None

        for t in self.list_checked_out_profiles():
            if t['transactionId'] == transaction_id:
                transaction = t
                break

        if not transaction:
            raise exceptions.TransactionNotFound()

        # step 2: make the proper API call
        url_part = 'url' if transaction['accessType'] == 'CONSOLE' else 'tokens'
        return self.britive.get(f'{self.base_url}/{transaction_id}/{url_part}')

    def checkin(self, transaction_id: str) -> dict:
        """
        Check in a checked out profile.

        :param transaction_id: The ID of the transaction.
        :return: Details of the checked in profile.
        """

        params = {
            'type': 'API'
        }
        return self.britive.put(f'{self.base_url}/{transaction_id}', params=params)

    def checkin_by_name(self, profile_name: str, environment_name: str) -> dict:
        """
        Check in a checked out profile by supplying the names of entities vs. the IDs of those entities

        :param profile_name: The name of the profile. Use `list_profiles()` to obtain the eligible profiles.
        :param environment_name: The name of the environment. Use `list_profiles()` to obtain the eligible environments.
        :return: Details of the checked in profile.
        """

        ids = self._get_profile_and_environment_ids_given_names(profile_name, environment_name)

        transaction_id = None
        for profile in self.list_checked_out_profiles():
            if profile['environmentId'] == ids['environment_id'] and profile['papId'] == ids['profile_id']:
                transaction_id = profile['transactionId']
                break
        if not transaction_id:
            raise ValueError(f'no checked out profile found for the given profile_name and environment_name')

        return self.checkin(transaction_id=transaction_id)

    def frequents(self) -> list:
        """
        Return list of frequently used profiles for the user.

        :return: List of profiles.
        """

        return self.britive.get(f'{self.base_url}/frequently-used')

    def favorites(self) -> list:
        """
        Return list of favorite profiles for the user.

        :return: List of profiles.
        """

        return self.britive.get(f'{self.base_url}/favorites')

    def whoami(self) -> dict:
        """
        Return details about the currently authenticated identity (user or service).

        :return: Details of the currently authenticated identity.
        """

        return self.britive.post(f'{self.britive.base_url}/auth/validate')['authenticationResult']

    def _get_profile_and_environment_ids_given_names(self, profile_name: str, environment_name: str) -> dict:
        profile_name = profile_name.lower()
        environment_name = environment_name.lower()
        data = self.list_profiles()
        profiles = {}
        for app in data:
            for profile in app['profiles']:
                envs = {}
                for env in profile['environments']:
                    envs[env['environmentName'].lower()] = env['environmentId']
                profiles[profile['profileName'].lower()] = {
                    'id': profile['profileId'],
                    'envs': envs
                }
        profile_id = profiles.get(profile_name, {'id': None}).get('id')
        environment_id = profiles.get(profile_name, {'envs': {}})['envs'].get(environment_name)

        if not profile_id:
            raise ValueError(f'profile name {profile_name} was not found as a valid profile')
        if not environment_id:
            raise ValueError(f'environment name {environment_name} was not found as a valid environment')

        return {
            'profile_id': profile_id,
            'environment_id': environment_id
        }

